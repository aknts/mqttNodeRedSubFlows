[{"id":"9cb03ea4.80c4d","type":"subflow","name":"AppToBeDeployed","info":"","category":"","in":[{"x":40,"y":60,"wires":[{"id":"e1a1287f.cfd378"}]}],"out":[{"x":2640,"y":60,"wires":[{"id":"7aa5e0ff.78711","port":0},{"id":"ade3b386.83d13","port":1}]}],"env":[{"name":"appname","type":"str","value":"mqtttestapp","ui":{"label":{"en-US":"App name"},"type":"input","opts":{"types":["str"]}}},{"name":"template","type":"json","value":"{\"apiVersion\":\"apps/v1\",\"kind\":\"Deployment\",\"metadata\":{\"labels\":{\"app\":\"mqtttestapp\"},\"name\":\"mqtttestapp\",\"namespace\":\"default\"},\"spec\":{\"replicas\":1,\"selector\":{\"matchLabels\":{\"app\":\"mqtttestapp\"}},\"strategy\":{\"rollingUpdate\":{\"maxSurge\":1,\"maxUnavailable\":0},\"type\":\"RollingUpdate\"},\"template\":{\"metadata\":{\"labels\":{\"app\":\"mqtttestapp\"}},\"spec\":{\"imagePullSecrets\":[{\"name\":\"regcred\"}],\"containers\":[{\"name\":\"mqtttestappcontainer\",\"image\":\"aknts/basicdockercontainer:latest\",\"lifecycle\":{\"postStart\":{\"exec\":{\"command\":[\"/bin/sh\",\"-c\",\"mosquitto_pub -h 192.168.2.241 -t global/logz -i mynodeid -m \\\"Hello\\\"\"]}},\"preStop\":{\"exec\":{\"command\":[\"/bin/sh\",\"-c\",\"mosquitto_pub -h 192.168.2.241 -t global/logz -i mynodeid -m \\\"Goodbye\\\"\"]}}},\"env\":[{\"name\":\"appname\",\"value\":\"mqtttestapp\"},{\"name\":\"appconfig\",\"value\":\"mqtttestappconfig\"},{\"name\":\"giturl\",\"value\":\"\"}],\"imagePullPolicy\":\"IfNotPresent\",\"resources\":{\"requests\":{\"cpu\":\"500m\",\"memory\":\"64Mi\"}}}],\"restartPolicy\":\"Always\"}}}}","ui":{"label":{"en-US":"Deployment template"},"type":"input","opts":{"types":["json"]}}},{"name":"giturl","type":"str","value":"https://github.com/aknts/mqtttestapp","ui":{"label":{"en-US":"Git url"},"type":"input","opts":{"types":["str"]}}},{"name":"service","type":"json","value":"","ui":{"label":{"en-US":"Service template"},"type":"input","opts":{"types":["json"]}}},{"name":"appsettings","type":"json","value":"{\"banner\":\"My ID is: \"}","ui":{"label":{"en-US":"App settings"},"type":"input","opts":{"types":["json"]}}},{"name":"delay","type":"num","value":"0","ui":{"label":{"en-US":"Delay deployment"},"type":"input","opts":{"types":["num"]}}}],"color":"#DDAA99","status":{"x":200,"y":160,"wires":[{"id":"5900feb6.71b4b","port":0}]}},{"id":"65747409.f4e33c","type":"function","z":"9cb03ea4.80c4d","name":"BuildConfig","func":"// Set our variables for this function node.\n// The template variable is filled from the corresponding field that is filled from the user\n// Also we set a variable as an object for the final configuration that we will pass to our app during deployment\n// A user friendly deployment name to differentiate each deployment even if we deploy the same app in all subflow nodes\nvar template=flow.get(\"template\");\nvar appname=flow.get(\"appname\");\nvar mynodeid=flow.get(\"mynodeid\");\nvar giturl=flow.get(\"giturl\");\nvar appconfig={};\nvar namespace = global.get(\"namespace\");\nvar nameid = global.get(\"nameid\");\nvar globalsettings = global.get(\"globalsettings\");\nvar appsettings = flow.get(\"appsettings\");\nvar kubeproxy = global.get(\"kubeproxy\")\nvar service = flow.get(\"service\");\nvar deploymentname = nameid+'-'+mynodeid+'-'+appname;\nflow.set(\"deploymentname\",deploymentname);\n// Getting the previous and next node plus setting up a varialble to find if the needed variables (app name, giturl and app settings)\n// are included or not in the template that the user provided plus an helping object\nvar previousnode = flow.get(\"previousnode\");\nvar nextnode = flow.get(\"nextnode\");\n//var myeenvvar = 'variables';\n// Get global settings, set the previous, next, own node id, get the name of the app and finally the app settings.\nif (previousnode) {\n    appconfig.previousnode = previousnode;\n}\nappconfig.nextnode = nextnode;\nappconfig.mynodeid = flow.get(\"mynodeid\");\nappconfig.nameid = nameid;\nappconfig.appname = appname;\nappconfig.kubeproxy = kubeproxy;\nappconfig.deploymentname = deploymentname;\nappconfig.namespace = namespace;\nappconfig.globalsettings = globalsettings;\nif (appsettings) {\n    appconfig.appsettings = appsettings;\n}\nif (service) {\n    service.metadata.name = deploymentname;\n    service.spec.selector.app = deploymentname;\n    appconfig.service = service;\n    flow.set(\"service\",service);\n    node.warn(flow.get(\"service\"));\n}\n// Fill the template with the corresponing data\ntemplate.metadata.labels.app = deploymentname;\ntemplate.metadata.name = deploymentname;\ntemplate.spec.selector.matchLabels.app = deploymentname;\ntemplate.spec.template.metadata.labels.app = deploymentname;\n// Some loops to check for the three needed variables that are included in the deployment template\nfor (let i = 0; i < template.spec.template.spec.containers.length; i++) {\n    template.spec.template.spec.containers[i].name = (deploymentname+'-container-'+i);\n    var mandvar = 0;\n    //var obj = {};\n    for (let ii = 0; ii < template.spec.template.spec.containers[i].env.length; ii++) {\n        switch(template.spec.template.spec.containers[i].env[ii].name) {\n            case 'appname':\n                template.spec.template.spec.containers[i].env[ii].value = appname;\n                mandvar += 1;\n            break;\n            case 'appconfig':\n                // We encode the data of the config that we pass to our app.\n                // Needed because the data contains characters that break the initiating bash script during the boot up. \n                template.spec.template.spec.containers[i].env[ii].value = \"'\"+Buffer.from(JSON.stringify(appconfig)).toString('base64')+\"'\";\n                mandvar += 2;\n            break;\n            case 'giturl':\n                if (giturl) {\n                    template.spec.template.spec.containers[i].env[ii].value = giturl;\n                }\n            break;\n        }\n    }\n    node.warn('test');\n    switch (mandvar){\n        case 0:\n            //obj.name = \"appname\";\n            //obj[\"value\"] = appname;\n            template.spec.template.spec.containers[i].env.push({\"appname\":appname});\n            //obj = {};\n            //obj[\"name\"] = \"appconfig\";\n            //obj[\"value\"] = \"'\"+Buffer.from(JSON.stringify(appconfig)).toString('base64')+\"'\";\n            template.spec.template.spec.containers[i].env.push({\"appname\":\"'\"+Buffer.from(JSON.stringify(appconfig)).toString('base64')+\"'\"});\n            //obj = {};\n        break;    \n        case 1:\n            //obj[\"name\"] = \"appconfig\";\n            //obj[\"value\"] = \"'\"+Buffer.from(JSON.stringify(appconfig)).toString('base64')+\"'\";\n            //template.spec.template.spec.containers[i].env.push(obj);\n            //obj = {};\n            template.spec.template.spec.containers[i].env.push({\"appname\":\"'\"+Buffer.from(JSON.stringify(appconfig)).toString('base64')+\"'\"});\n        break;\n        case 2:\n//            obj[\"name\"] = \"appname\";\n//            obj[\"value\"] = appname;\n//            template.spec.template.spec.containers[i].env.push(obj);\n//            obj = {};\n            template.spec.template.spec.containers[i].env.push({\"appname\":appname});\n        break;\n    }\n}\n// Build the final message, load payload with the template and add the url that we send our request\nnode.warn(template);\nmsg.payload=JSON.stringify(template);\nmsg.method = 'POST';\nmsg.url = 'http://'+kubeproxy+'/apis/apps/v1/namespaces/'+namespace+'/deployments';\nreturn msg;","outputs":1,"noerr":0,"x":870,"y":60,"wires":[["5fedc483.73a98c"]]},{"id":"3cbdc32c.886c7c","type":"http request","z":"9cb03ea4.80c4d","name":"","method":"use","ret":"obj","paytoqs":false,"url":"","tls":"","persist":false,"proxy":"","authType":"","x":1650,"y":60,"wires":[["ade3b386.83d13","565a54fb.72190c"]]},{"id":"ade3b386.83d13","type":"function","z":"9cb03ea4.80c4d","name":"CheckAndChangeURL","func":"// First check if we did't get a failure message during deployment \n// and then change the url to request for its status before we proceed\nvar output1;\nvar output2;\nif ((msg.payload.status == \"Failure\") && (msg.payload.reason != \"AlreadyExists\")) {\n    node.status({fill:\"red\",shape:\"dot\",text:\"Node deployment failed\"});\n    throw(msg.payload.message);\n} else if ((msg.payload.status == \"Failure\") && (msg.payload.reason == \"AlreadyExists\")) {\n    node.status({fill:\"green\",shape:\"dot\",text:\"Node already exists\"});\n    output1 = null;\n    msg.payload=flow.get(\"nextnode\");\n    output2 = msg;\n} else {\n    msg.payload = '';\n    // If we are patching a deployment, we clean the msg and change the url to be able to get the status message.\n    if (msg.method == 'PATCH'){\n        msg.url = msg.url+'/status';\n    } else {\n        msg.url = msg.url+'/'+flow.get(\"deploymentname\")+'/status';\n    }\n    delete msg.method;\n    delete msg.md5;\n    output1 = msg;\n    output2 = null;\n}\nreturn [output1, output2];","outputs":2,"noerr":0,"x":1860,"y":60,"wires":[["f16f650a.9ab0b8"],["f18af736.3a7038"]]},{"id":"73eaca54.272cd4","type":"http request","z":"9cb03ea4.80c4d","name":"","method":"GET","ret":"obj","paytoqs":false,"url":"","tls":"","persist":false,"proxy":"","authType":"","x":2250,"y":60,"wires":[["9a0739ec.1d5eb8","7aa5e0ff.78711"]]},{"id":"7aa5e0ff.78711","type":"function","z":"9cb03ea4.80c4d","name":"CheckStatusMessages","func":"// After requesting for the status of deployment, we get a json object we need to filter out our information\n// If succesfull deployment then pass an ok message to avoid looping through this and deploy the rest of the nodes\nvar output1;\nvar output2;\n\nif (typeof msg.payload.status === 'string') {\n    var condition = 0;\n    var status = msg.payload.status;\n} else {\n    condition = msg.payload.status.conditions[0];\n    status = 0;\n}\n\nif (msg.retry === undefined) {\n    msg.retry = 0;\n}\n\nif (status == \"Failure\"){\n    node.status({fill:\"red\",shape:\"dot\",text:\"Deployment failled\"});\n    throw(msg.payload.message);\n}\n\nif ((condition.type == \"Available\") && (condition.status == \"True\")) {\n    msg.payload=flow.get(\"nextnode\");\n    delete msg.retry;\n    output1=msg;\n    output2=null;\n    node.status({fill:\"green\",shape:\"dot\",text:\"Node deployed\"});\n    node.done('Deployment of '+flow.get(\"deploymentname\")+' is finished.');\n} else if ((condition.type == \"Progressing\") && (condition.status == \"True\")) {\n    msg.payload=flow.get(\"nextnode\");\n    delete msg.retry;\n    output1=msg;\n    output2=null;\n    node.status({fill:\"green\",shape:\"dot\",text:\"Node redeployed\"});\n    node.done(condition.message);\n} else {\n    output1=null;\n    output2=msg;\n    node.status({fill:\"yellow\",shape:\"dot\",text:\"Node deployed with some warnings\"});\n    node.warn('Deployment of '+flow.get(\"deploymentname\")+' is finished but something is wrong. Checking again.')\n    msg.retry = msg.retry + 1;\n}\n\nif (msg.retry >= 9){\n    node.warn('Failed to determine deployment status. Continuing to deploy the rest of the nodes. Please check your deployment through kubectl.');\n    msg.payload=flow.get(\"nextnode\");\n    delete msg.retry;\n    output1=msg;\n    output2=null;\n    node.status({fill:\"yellow\",shape:\"dot\",text:\"Node deployed, unknown status, continuing.\"});\n    node.done(condition.message);\n}\n\nreturn [output1,output2];","outputs":2,"noerr":0,"x":2480,"y":120,"wires":[[],["f16f650a.9ab0b8"]]},{"id":"9a0739ec.1d5eb8","type":"debug","z":"9cb03ea4.80c4d","name":"","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","x":2450,"y":180,"wires":[]},{"id":"e1109825.402358","type":"function","z":"9cb03ea4.80c4d","name":"FindNeighbors","func":"// Get node's id from incoming message, \n// set it as a variable for this function node and also as a flow variable to be accesible downstream\n// and finally get the order of nodes in the master flow\nvar mynodeid = msg.payload;\nflow.set(\"mynodeid\",mynodeid)\nvar flownodesorder = global.get(\"flownodesorder\");\n// Loop through the master's flow order, locate this subflow id and get the index of the position\nvar i=0;\nwhile (i < flownodesorder.length) {\n    if (flownodesorder[i] == mynodeid) {\n        var ii=i;\n    }\n    i++;\n}\n// Use the index that we found in previous state to find the previous and next subflow node id\n// Set two variables that are passed to the final deployment, this way we arrange to which node our app can send/receive messages through the mqtt broker\nif (ii > 0) {\n    flow.set(\"previousnode\",flownodesorder[ii-1]);\n} else {\n    flow.set(\"previousnode\",0);\n}\nif (ii < flownodesorder.length-1) {\n    flow.set(\"nextnode\",flownodesorder[ii+1])\n} else {\n    flow.set(\"nextnode\",0);\n}\nreturn msg;","outputs":1,"noerr":0,"x":680,"y":60,"wires":[["65747409.f4e33c","db0d7fc1.c816e"]]},{"id":"5900feb6.71b4b","type":"status","z":"9cb03ea4.80c4d","name":"","scope":null,"x":80,"y":160,"wires":[[]]},{"id":"565a54fb.72190c","type":"debug","z":"9cb03ea4.80c4d","name":"","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"true","targetType":"full","x":1850,"y":180,"wires":[]},{"id":"f16f650a.9ab0b8","type":"delay","z":"9cb03ea4.80c4d","name":"","pauseType":"delay","timeout":"5","timeoutUnits":"seconds","rate":"1","nbRateUnits":"1","rateUnits":"second","randomFirst":"1","randomLast":"5","randomUnits":"seconds","drop":false,"x":2080,"y":100,"wires":[["73eaca54.272cd4","f18af736.3a7038"]]},{"id":"e1a1287f.cfd378","type":"function","z":"9cb03ea4.80c4d","name":"CheckEnviromentalVariables","func":"function validURL(str) {\n  var pattern = new RegExp('^(https?:\\\\/\\\\/)?'+ // protocol\n    '((([a-z\\\\d]([a-z\\\\d-]*[a-z\\\\d])*)\\\\.)+[a-z]{2,}|'+ // domain name\n    '((\\\\d{1,3}\\\\.){3}\\\\d{1,3}))'+ // OR ip (v4) address\n    '(\\\\:\\\\d+)?(\\\\/[-a-z\\\\d%_.~+]*)*'+ // port and path\n    '(\\\\?[;&a-z\\\\d%_.~+=-]*)?'+ // query string\n    '(\\\\#[-a-z\\\\d_]*)?$','i'); // fragment locator\n  return !!pattern.test(str);\n}\n\nif (env.get(\"appname\")) {\n    flow.set(\"appname\", env.get(\"appname\"))\n} else {\n    node.status({fill:\"red\",shape:\"dot\",text:\"Form not filled correclty.\"});\n    throw(\"App name is empty.\");\n}\nif (Object.keys(env.get(\"template\")).length !== 0 && typeof env.get(\"template\") === 'object') {\n    flow.set(\"template\", env.get(\"template\"));\n} else {\n    node.status({fill:\"red\",shape:\"dot\",text:\"Form not filled correclty.\"});\n    throw(\"Template is not a valid JSON object.\");\n}\nif (env.get(\"giturl\") && validURL(env.get(\"giturl\"))) { \n    flow.set(\"giturl\", env.get(\"giturl\"));\n} else {\n    node.status({fill:\"red\",shape:\"dot\",text:\"Not a valid url\"});\n    node.warn(\"Url is not valid.\");\n}\nif (typeof env.get(\"appsettings\") === 'object') {\n    flow.set(\"appsettings\", env.get(\"appsettings\"));\n} else {\n    node.status({fill:\"blue\",shape:\"dot\",text:\"Application settings is not a valid JSON object\"});\n    node.warn('Application settings is not a valid JSON object');\n} \nif (typeof env.get(\"service\") === 'object') {\n    flow.set(\"service\", env.get(\"service\"));\n} else {\n    node.status({fill:\"blue\",shape:\"dot\",text:\"Service is not a valid JSON object\"});\n    node.warn('Service is not a valid JSON object');\n}\nif (env.get(\"delay\")) {\n    msg.delay = env.get(\"delay\");\n} else {\n    msg.delay = 0;\n}\n\nreturn msg;","outputs":1,"noerr":0,"x":220,"y":60,"wires":[["8c218a3c.f1ea78","a049fdb0.cb513"]]},{"id":"5fedc483.73a98c","type":"md5","z":"9cb03ea4.80c4d","name":"","fieldToHash":"payload","fieldTypeToHash":"msg","hashField":"md5","hashFieldType":"msg","x":1030,"y":60,"wires":[["75fb2395.803bcc"]]},{"id":"75fb2395.803bcc","type":"function","z":"9cb03ea4.80c4d","name":"CompareConfigs","func":"// In the previous step we have produced an md5 hash feeding the template.\n// We keep the hash in a gloabal array and this way we can know if the template is altered.\n// If altered we change the url and feed it to the api to change the deployment that already exists.\n// If a previous hash doesn't exist we add a new object to the array and change the url to build the deployment.\n\n// Some vars for all the previous steps\nvar template=flow.get(\"template\");\nvar appname=flow.get(\"appname\");\nvar service=flow.get(\"service\");\nvar mynodeid=flow.get(\"mynodeid\");\nvar deploymentname = global.get(\"nameid\")+'-'+mynodeid+'-'+appname;\nvar confighash = msg.md5;\nvar nodeexists = 0;\n//var appconfig={};\nvar namespace = global.get(\"namespace\");\nvar kubeproxy = global.get(\"kubeproxy\");\nvar appnameobj = {};\nvar msg2 = {};\nvar flownodesappname = global.get(\"flownodesappname\");\n// A for to patch the deployment in case that the tempate is changed . If the main app is changed the deployment stops. \nif (Array.isArray(flownodesappname) && flownodesappname.length) {\n    for (let i = 0; i < flownodesappname.length; i++) {\n        //if (flownodesappname[i].nodeid == mynodeid) {\n        if (flownodesappname[i].deploymentname == deploymentname) {    \n            nodeexists = 1;\n            /*\n            if (flownodesappname[i].appname != appname) {\n                throw(\"The main app has changed, redeployment has stopped. Please delete deployment and add a new node with the new app.\")\n            }*/\n            if (flownodesappname[i].confighash != confighash) {\n                flownodesappname[i].confighash = confighash;\n                msg.url = 'http://'+kubeproxy+'/apis/apps/v1/namespaces/'+namespace+'/deployments/'+deploymentname;\n                msg.method = 'PATCH';\n                msg.headers = {};\n                msg.headers[\"Content-Type\"] = 'application/strategic-merge-patch+json';\n                if (service && flownodesappname[i].confighash != confighash) {\n                    msg.delay = 5;\n                    node.warn('Service metadata name:'+service.metadata.name);\n                    msg2.url = 'http://'+kubeproxy+'/api/v1/namespaces/'+namespace+'/services/'+service.metadata.name;\n                    msg2.method = 'PATCH';\n                    msg2.headers = {};\n                    msg2.headers[\"Content-Type\"] = 'application/strategic-merge-patch+json';\n                }\n                msg.delay = 0;\n            }\n        }\n    }\n}\n// If the deployment is a new one, we add a new object to our list.\nif (nodeexists === 0){\n    for (let i = 0; i < flownodesappname.length; i++) {\n    //   if (flownodesappname[i].nodeid == mynodeid) {\n        if (flownodesappname[i].deploymentname == deploymentname) {\n            flownodesappname.splice(i, 1);\n       }\n    }\n    //appnameobj[\"nodeid\"] = mynodeid;\n    //appnameobj[\"appname\"] = appname;\n    appnameobj[\"deploymentname\"] = deploymentname;\n    appnameobj[\"confighash\"] = confighash;\n    flownodesappname.push(appnameobj);\n    global.set(\"flownodesappname\",flownodesappname);\n    msg.url = 'http://'+kubeproxy+'/apis/apps/v1/namespaces/'+namespace+'/deployments';\n    msg.method = 'POST';\n    if (service) {\n        msg.delay = 5;\n        node.warn('Service metadata name:'+service.metadata.name);\n        msg2.url = 'http://'+kubeproxy+'/api/v1/namespaces/'+namespace+'/services';\n        msg2.method = 'POST';\n        msg2.payload = service;\n        node.warn(msg2);\n    }\n    msg.delay = 0;\n}\n// Final parsing before the http request.\nnode.warn(global.get(\"flownodesappname\"));\nmsg.payload = JSON.parse(msg.payload);\nreturn [msg,msg2];","outputs":2,"noerr":0,"x":1210,"y":60,"wires":[["9d2602d9.6abf5"],["5afddd5f.cff474"]]},{"id":"140b6268.2c228e","type":"debug","z":"9cb03ea4.80c4d","name":"","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"true","targetType":"full","x":1640,"y":180,"wires":[]},{"id":"f18af736.3a7038","type":"debug","z":"9cb03ea4.80c4d","name":"","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"true","targetType":"full","x":2240,"y":200,"wires":[]},{"id":"db0d7fc1.c816e","type":"debug","z":"9cb03ea4.80c4d","name":"","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"true","targetType":"full","x":960,"y":200,"wires":[]},{"id":"5afddd5f.cff474","type":"http request","z":"9cb03ea4.80c4d","name":"","method":"use","ret":"obj","paytoqs":false,"url":"","tls":"","persist":false,"proxy":"","authType":"","x":1410,"y":180,"wires":[["4db36e2.3b4b99"]]},{"id":"7e62aab9.f29404","type":"debug","z":"9cb03ea4.80c4d","name":"","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"payload","targetType":"msg","x":1930,"y":280,"wires":[]},{"id":"9d2602d9.6abf5","type":"delay","z":"9cb03ea4.80c4d","name":"","pauseType":"delayv","timeout":"1","timeoutUnits":"seconds","rate":"1","nbRateUnits":"1","rateUnits":"second","randomFirst":"1","randomLast":"5","randomUnits":"seconds","drop":false,"x":1440,"y":60,"wires":[["3cbdc32c.886c7c","140b6268.2c228e"]]},{"id":"8c218a3c.f1ea78","type":"delay","z":"9cb03ea4.80c4d","name":"","pauseType":"delayv","timeout":"1","timeoutUnits":"seconds","rate":"1","nbRateUnits":"1","rateUnits":"second","randomFirst":"1","randomLast":"5","randomUnits":"seconds","drop":false,"x":480,"y":60,"wires":[["e1109825.402358"]]},{"id":"a049fdb0.cb513","type":"debug","z":"9cb03ea4.80c4d","name":"","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"delay","targetType":"msg","x":440,"y":180,"wires":[]},{"id":"4db36e2.3b4b99","type":"function","z":"9cb03ea4.80c4d","name":"Inform about service deployment","func":"node.status({fill:\"blue\",shape:\"dot\",text:\"Attached service deployed\"});\nreturn msg;","outputs":1,"noerr":0,"x":1690,"y":240,"wires":[["7e62aab9.f29404"]]},{"id":"12ad9847.ba7328","type":"subflow:9cb03ea4.80c4d","z":"11ac64d5.10699b","name":"","x":480,"y":320,"wires":[[]]}]