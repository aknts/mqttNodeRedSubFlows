[{"id":"9cb03ea4.80c4d","type":"subflow","name":"mqttStrandBaseNode","info":"","category":"","in":[{"x":40,"y":60,"wires":[{"id":"e1a1287f.cfd378"}]}],"out":[{"x":2180,"y":60,"wires":[{"id":"7aa5e0ff.78711","port":0},{"id":"ade3b386.83d13","port":1}]}],"env":[{"name":"type","type":"str","value":"mqtttestapp","ui":{"label":{"en-US":"App module"},"type":"input","opts":{"types":["str"]}}},{"name":"template","type":"json","value":"{\"apiVersion\":\"apps/v1\",\"kind\":\"Deployment\",\"metadata\":{\"labels\":{\"app\":\"mqtttestapp\"},\"name\":\"mqtttestapp\",\"namespace\":\"default\"},\"spec\":{\"replicas\":1,\"selector\":{\"matchLabels\":{\"app\":\"mqtttestapp\"}},\"strategy\":{\"rollingUpdate\":{\"maxSurge\":1,\"maxUnavailable\":0},\"type\":\"RollingUpdate\"},\"template\":{\"metadata\":{\"labels\":{\"app\":\"mqtttestapp\"}},\"spec\":{\"imagePullSecrets\":[{\"name\":\"regcred\"}],\"containers\":[{\"name\":\"mqtttestappcontainer\",\"image\":\"aknts/mqttstrand:latest\",\"env\":[{\"name\":\"appmodule\",\"value\":\"mqtttestapp\"},{\"name\":\"appconfig\",\"value\":\"mqtttestappconfig\"},{\"name\":\"gitprofileurl\",\"value\":\"\"}],\"imagePullPolicy\":\"IfNotPresent\",\"resources\":{\"requests\":{\"cpu\":\"500m\",\"memory\":\"64Mi\"}}}],\"restartPolicy\":\"Always\"}}}}","ui":{"label":{"en-US":"Deployment template"},"type":"input","opts":{"types":["json"]}}}],"color":"#DDAA99","status":{"x":200,"y":160,"wires":[{"id":"5900feb6.71b4b","port":0}]}},{"id":"65747409.f4e33c","type":"function","z":"9cb03ea4.80c4d","name":"BuildConfig","func":"// Set our variables for this function node.\n// The template variable is filled from the corresponding field that is filled from the user\n// Also we set a variable as an object for the final configuration that we will pass to our app during deployment\n// A user friendly deployment name to differentiate each deployment even if we deploy the same app in all subflow nodes\nvar template=flow.get(\"template\");\nvar type=flow.get(\"type\");\nvar mynodeid=flow.get(\"mynodeid\");\nvar appconfig={};\nvar deploymentname = global.get(\"nameid\")+'-'+mynodeid+'-'+type;\nflow.set(\"deploymentname\",deploymentname);\n// Getting the previous and next node plus setting up a varialble to find if the needed variables (appmodule, appconfig and gitprofileurl)\n// are included or not in the template that the user provided plus an helping object\nvar previousnode = flow.get(\"previousnode\");\nvar nextnode = flow.get(\"nextnode\");\nvar myeenvvar = 'variables';\nvar obj = {};\n// Get the broker url, set the previous, next, own node id and get the type of the app.\nappconfig.broker = 'mqtt://'+global.get(\"broker\");\nif (previousnode !== 0) {\n    appconfig.previousnode = previousnode;\n}\nappconfig.nextnode = nextnode;\nappconfig.mynodeid = flow.get(\"mynodeid\");\nappconfig.type = type;\n// Fill the template with the corresponing data\ntemplate.metadata.labels.app = type;\ntemplate.metadata.name = deploymentname;\ntemplate.spec.selector.matchLabels.app = type;\ntemplate.spec.template.metadata.labels.app = type;\ntemplate.spec.template.spec.containers[0].name = (type+'container');\n// Some loops to check for the three needed variables that are included in the deployment template\nfor (let i = 0; i < template.spec.template.spec.containers[0].env.length; i++) {\n    switch(template.spec.template.spec.containers[0].env[i].name) {\n    case 'appmodule':\n    template.spec.template.spec.containers[0].env[i].value = type;\n    myeenvvar=myeenvvar+'appmodule';\n    break;\n    case 'appconfig':\n    // We encode the data of the config that we pass to our app.\n    // Needed because the data contains characters that break the initiating bash script during the boot up. \n    template.spec.template.spec.containers[0].env[i].value = \"'\"+Buffer.from(JSON.stringify(appconfig)).toString('base64')+\"'\";\n    myeenvvar=myeenvvar+'appconfig';\n    break;\n    case 'gitprofileurl':\n    template.spec.template.spec.containers[0].env[i].value = global.get(\"gitprofileurl\");\n    myeenvvar=myeenvvar+'gitprofileurl';\n    break;\n    default:\n    }\n}\nif (myeenvvar.search(\"appmodule\") === -1){\n    obj[\"name\"] = \"appmodule\";\n    obj[\"value\"] = type;\n    template.spec.template.spec.containers[0].env.push(obj);\n}\nif (myeenvvar.search(\"appconfig\") === -1){\n    obj = {};\n    obj[\"name\"] = \"appconfig\";\n    // Same as before\n    obj[\"value\"] = \"'\"+Buffer.from(JSON.stringify(appconfig)).toString('base64')+\"'\";\n    template.spec.template.spec.containers[0].env.push(obj);\n}\nif (myeenvvar.search(\"gitprofileurl\") === -1){\n    obj = {};\n    obj[\"name\"] = \"gitprofileurl\";\n    obj[\"value\"] = global.get(\"gitprofileurl\");\n    template.spec.template.spec.containers[0].env.push(obj);\n}\n// Build the final message, load payload with the template and add the url that we send our request\nmsg.payload=JSON.stringify(template);\nmsg.method = 'POST';\nmsg.url = 'http://'+global.get(\"kubeproxy\")+'/apis/apps/v1/namespaces/default/deployments';\nreturn msg;","outputs":1,"noerr":0,"x":650,"y":60,"wires":[["5fedc483.73a98c"]]},{"id":"3cbdc32c.886c7c","type":"http request","z":"9cb03ea4.80c4d","name":"","method":"use","ret":"obj","paytoqs":false,"url":"","tls":"","persist":false,"proxy":"","authType":"","x":1190,"y":60,"wires":[["ade3b386.83d13","565a54fb.72190c"]]},{"id":"ade3b386.83d13","type":"function","z":"9cb03ea4.80c4d","name":"CheckAndChangeURL","func":"// First check if we did't get a failure message during deployment \n// and then change the url to request for its status before we proceed\nvar output1;\nvar output2;\nif ((msg.payload.status == \"Failure\") && (msg.payload.reason != \"AlreadyExists\")) {\n    node.status({fill:\"red\",shape:\"dot\",text:\"Node deployment failed\"});\n    throw(msg.payload.message);\n} else if ((msg.payload.status == \"Failure\") && (msg.payload.reason == \"AlreadyExists\")) {\n    node.status({fill:\"green\",shape:\"dot\",text:\"Node already exists\"});\n    output1 = null;\n    msg.payload=flow.get(\"nextnode\");\n    output2 = msg;\n} else {\n    msg.payload = '';\n    // If we are patching a deployment, we clean the msg and change the url to be able to get the status message.\n    if (msg.method == 'PATCH'){\n        msg.url = msg.url+'/status';\n    } else {\n        msg.url = msg.url+'/'+flow.get(\"deploymentname\")+'/status';\n    }\n    delete msg.method;\n    delete msg.md5;\n    output1 = msg;\n    output2 = null;\n}\nreturn [output1, output2];","outputs":2,"noerr":0,"x":1400,"y":60,"wires":[["f16f650a.9ab0b8"],["f18af736.3a7038"]]},{"id":"73eaca54.272cd4","type":"http request","z":"9cb03ea4.80c4d","name":"","method":"GET","ret":"obj","paytoqs":false,"url":"","tls":"","persist":false,"proxy":"","authType":"","x":1790,"y":60,"wires":[["9a0739ec.1d5eb8","7aa5e0ff.78711"]]},{"id":"7aa5e0ff.78711","type":"function","z":"9cb03ea4.80c4d","name":"CheckStatusMessages","func":"// After requesting for the status of deployment, we get a json object we need to filter out our information\n// If succesfull deployment then pass an ok message to avoid looping through this and deploy the rest of the nodes\nvar output1;\nvar output2;\nvar condition=msg.payload.status.conditions[0];\n\nif ((condition.type == \"Available\") && (condition.status == \"True\")) {\n    msg.payload=flow.get(\"nextnode\");\n    output1=msg;\n    output2=null;\n    node.status({fill:\"green\",shape:\"dot\",text:\"Node deployed\"});\n    node.done('Deployment of '+flow.get(\"deploymentname\")+' is finished.');\n} \n\nif ((condition.type == \"Progressing\") && (condition.status == \"True\")) {\n    msg.payload=flow.get(\"nextnode\");\n    output1=msg;\n    output2=null;\n    node.status({fill:\"green\",shape:\"dot\",text:\"Node redeployed\"});\n    node.done(condition.message);\n} \n\nif (msg.payload.status == \"Failure\") {\n    node.status({fill:\"yellow\",shape:\"dot\",text:\"Status fail\"});\n    node.warn(msg.payload.message);\n    msg.retry = msg.retry+1;\n    output1=null;\n    output2=msg;\n} \n\nif (msg.retry == 3){\n    node.warn('Status failed, continuing. Please check your deployment through kubectl.');\n    msg.payload=flow.get(\"nextnode\");\n    output1=msg;\n    output2=null;\n    node.status({fill:\"green\",shape:\"dot\",text:\"Node redeployed\"});\n    node.done(condition.message);\n}\n\nif (condition == 'undefined') {\n    output1=null;\n    output2=msg;\n    node.status({fill:\"yellow\",shape:\"dot\",text:\"Node deployed with some warnings\"});\n    node.done('Deployment of '+flow.get(\"deploymentname\")+' is finished. Maybe some warnings have poped up in the debug window. Please check.')\n}\n\n\nreturn [output1,output2];","outputs":2,"noerr":0,"x":2020,"y":120,"wires":[[],["f16f650a.9ab0b8"]]},{"id":"9a0739ec.1d5eb8","type":"debug","z":"9cb03ea4.80c4d","name":"","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","x":1990,"y":180,"wires":[]},{"id":"e1109825.402358","type":"function","z":"9cb03ea4.80c4d","name":"FindNeighbors","func":"// Get node's id from incoming message, \n// set it as a variable for this function node and also as a flow variable to be accesible downstream\n// and finally get the order of nodes in the master flow\nvar mynodeid = msg.payload;\nflow.set(\"mynodeid\",mynodeid)\nvar flownodesorder = global.get(\"flownodesorder\");\n// Loop through the master's flow order, locate this subflow id and get the index of the position\nvar i=0;\nwhile (i < flownodesorder.length) {\n    if (flownodesorder[i] == mynodeid) {\n        var ii=i;\n    }\n    i++;\n}\n// Use the index that we found in previous state to find the previous and next subflow node id\n// Set two variables that are passed to the final deployment, this way we arrange to which node our app can send/receive messages through the mqtt broker\nif (ii > 1) {\n    flow.set(\"previousnode\",flownodesorder[ii-1]);\n} else {\n    flow.set(\"previousnode\",0);\n}\nif (ii < flownodesorder.length-1) {\n    flow.set(\"nextnode\",flownodesorder[ii+1])\n} else {\n    flow.set(\"nextnode\",0);\n}\nreturn msg;","outputs":1,"noerr":0,"x":460,"y":60,"wires":[["65747409.f4e33c"]]},{"id":"5900feb6.71b4b","type":"status","z":"9cb03ea4.80c4d","name":"","scope":null,"x":80,"y":160,"wires":[[]]},{"id":"565a54fb.72190c","type":"debug","z":"9cb03ea4.80c4d","name":"","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"true","targetType":"full","x":1390,"y":180,"wires":[]},{"id":"f16f650a.9ab0b8","type":"delay","z":"9cb03ea4.80c4d","name":"","pauseType":"delay","timeout":"5","timeoutUnits":"seconds","rate":"1","nbRateUnits":"1","rateUnits":"second","randomFirst":"1","randomLast":"5","randomUnits":"seconds","drop":false,"x":1620,"y":100,"wires":[["73eaca54.272cd4","f18af736.3a7038"]]},{"id":"e1a1287f.cfd378","type":"function","z":"9cb03ea4.80c4d","name":"CheckEnviromentalVariables","func":"if (env.get(\"type\") == \"\") {\n    node.status({fill:\"red\",shape:\"dot\",text:\"Form not filled correclty.\"});\n    throw(\"App module is empty.\");\n} else {\n    flow.set(\"type\", env.get(\"type\"))\n}\nif (env.get(\"template\") == \"\") {\n    node.status({fill:\"red\",shape:\"dot\",text:\"Form not filled correclty.\"});\n    throw(\"Deployment template is empty.\");\n} else {\n    flow.set(\"template\", env.get(\"template\"))\n}\nreturn msg;","outputs":1,"noerr":0,"x":220,"y":60,"wires":[["e1109825.402358"]]},{"id":"5fedc483.73a98c","type":"md5","z":"9cb03ea4.80c4d","name":"","fieldToHash":"payload","fieldTypeToHash":"msg","hashField":"md5","hashFieldType":"msg","x":810,"y":60,"wires":[["75fb2395.803bcc"]]},{"id":"75fb2395.803bcc","type":"function","z":"9cb03ea4.80c4d","name":"CompareConfigs","func":"// In the previous step we have produced an md5 hash feeding the template.\n// We keep the hash in a gloabal array and this way we can know if the template is altered.\n// If altered we change the url and feed it to the api to change the deployment that already exists.\n// If a previous hash doesn't exist we add a new object to the array and change the url to build the deployment.\n\n// Some vars for all the previous steps\nvar template=flow.get(\"template\");\nvar type=flow.get(\"type\");\nvar mynodeid=flow.get(\"mynodeid\");\nvar deploymentname = global.get(\"nameid\")+'-'+mynodeid+'-'+type;\nvar confighash = msg.md5;\nvar nodeexists = 0;\nvar appconfig={};\nvar appnameobj = {};\nvar flownodesappname = global.get(\"flownodesappname\");\n// A for to patch the deployment in case that the tempate is changed . If the main app is changed the deployment stops. \nif (Array.isArray(flownodesappname) || flownodesappname.length) {\n    for (let i = 0; i < flownodesappname.length; i++) {\n        if (flownodesappname[i].nodeid == mynodeid) {\n            nodeexists = 1;\n            node.warn(flownodesappname[i].type+'-'+type);\n            if (flownodesappname[i].type != type) {\n                throw(\"The main app has changed, redeployment has stopped. Please delete deployment and add a new node with the new app.\")\n            }\n            if (flownodesappname[i].confighash != confighash) {\n                flownodesappname[i].confighash = confighash;\n                msg.url = 'http://'+global.get(\"kubeproxy\")+'/apis/apps/v1/namespaces/default/deployments/'+deploymentname;\n                msg.method = 'PATCH';\n                msg.headers = {};\n                msg.headers[\"Content-Type\"] = 'application/strategic-merge-patch+json';\n            }\n        }\n    }\n}\n// If the deployment is a new one, we add a new object to our list.\nif (nodeexists == 0){\n    appnameobj[\"nodeid\"] = mynodeid;\n    appnameobj[\"type\"] = type;\n    appnameobj[\"confighash\"] = confighash;\n    flownodesappname.push(appnameobj);\n    global.set(\"flownodesappname\",flownodesappname);\n    msg.url = 'http://'+global.get(\"kubeproxy\")+'/apis/apps/v1/namespaces/default/deployments';\n    msg.method = 'POST';\n}\n// Final parsing before the http request.\nnode.warn(global.get(\"flownodesappname\"));\nmsg.payload = JSON.parse(msg.payload);\nreturn msg;","outputs":1,"noerr":0,"x":990,"y":60,"wires":[["3cbdc32c.886c7c","140b6268.2c228e"]]},{"id":"140b6268.2c228e","type":"debug","z":"9cb03ea4.80c4d","name":"","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"true","targetType":"full","x":1180,"y":180,"wires":[]},{"id":"f18af736.3a7038","type":"debug","z":"9cb03ea4.80c4d","name":"","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"true","targetType":"full","x":1780,"y":200,"wires":[]},{"id":"87c6560e.3d9028","type":"subflow:9cb03ea4.80c4d","z":"11ac64d5.10699b","name":"","x":600,"y":100,"wires":[["ac82d429.fc5028"]]}]