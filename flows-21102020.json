[{"id":"11ac64d5.10699b","type":"tab","label":"Flow 1","disabled":false,"info":""},{"id":"9cb03ea4.80c4d","type":"subflow","name":"mqttStrandBaseNode","info":"","category":"","in":[{"x":40,"y":60,"wires":[{"id":"e1a1287f.cfd378"}]}],"out":[{"x":2180,"y":60,"wires":[{"id":"7aa5e0ff.78711","port":0},{"id":"ade3b386.83d13","port":1}]}],"env":[{"name":"type","type":"str","value":"mqtttestapp","ui":{"label":{"en-US":"App module"},"type":"input","opts":{"types":["str"]}}},{"name":"template","type":"json","value":"{\"apiVersion\":\"apps/v1\",\"kind\":\"Deployment\",\"metadata\":{\"labels\":{\"app\":\"mqtttestapp\"},\"name\":\"mqtttestapp\",\"namespace\":\"default\"},\"spec\":{\"replicas\":1,\"selector\":{\"matchLabels\":{\"app\":\"mqtttestapp\"}},\"strategy\":{\"rollingUpdate\":{\"maxSurge\":1,\"maxUnavailable\":0},\"type\":\"RollingUpdate\"},\"template\":{\"metadata\":{\"labels\":{\"app\":\"mqtttestapp\"}},\"spec\":{\"imagePullSecrets\":[{\"name\":\"regcred\"}],\"containers\":[{\"name\":\"mqtttestappcontainer\",\"image\":\"aknts/mqttstrand:latest\",\"env\":[{\"name\":\"appmodule\",\"value\":\"mqtttestapp\"},{\"name\":\"appconfig\",\"value\":\"mqtttestappconfig\"},{\"name\":\"gitprofileurl\",\"value\":\"\"}],\"imagePullPolicy\":\"IfNotPresent\",\"resources\":{\"requests\":{\"cpu\":\"500m\",\"memory\":\"64Mi\"}}}],\"restartPolicy\":\"Always\"}}}}","ui":{"label":{"en-US":"Deployment template"},"type":"input","opts":{"types":["json"]}}}],"color":"#DDAA99","status":{"x":200,"y":160,"wires":[{"id":"5900feb6.71b4b","port":0}]}},{"id":"10db5822.97cf88","type":"subflow","name":"mqttStrandSettings","info":"","category":"","in":[{"x":40,"y":60,"wires":[{"id":"8b475ac3.83c4f8"}]}],"out":[{"x":780,"y":60,"wires":[{"id":"1a4c35c9.570a8a","port":0}]}],"env":[{"name":"nameid","type":"str","value":"","ui":{"label":{"en-US":"Pipeline Name"},"type":"input","opts":{"types":["str"]}}},{"name":"kubeproxy","type":"str","value":"","ui":{"label":{"en-US":"Kubectl Proxy"},"type":"input","opts":{"types":["str"]}}},{"name":"broker","type":"str","value":"","ui":{"label":{"en-US":"MQTT Broker"},"type":"input","opts":{"types":["str"]}}},{"name":"gitprofileurl","type":"str","value":"","ui":{"label":{"en-US":"Git profile url"},"type":"input","opts":{"types":["str"]}}}],"color":"#DDAA99","status":{"x":260,"y":160,"wires":[{"id":"9ddecb56.4f7548","port":0}]}},{"id":"65747409.f4e33c","type":"function","z":"9cb03ea4.80c4d","name":"BuildConfig","func":"// Set our variables for this function node.\n// The template variable is filled from the corresponding field that is filled from the user\n// Also we set a variable as an object for the final configuration that we will pass to our app during deployment\n// A user friendly deployment name to differentiate each deployment even if we deploy the same app in all subflow nodes\nvar template=flow.get(\"template\");\nvar type=flow.get(\"type\");\nvar mynodeid=flow.get(\"mynodeid\");\nvar appconfig={};\nvar deploymentname = global.get(\"nameid\")+'-'+mynodeid+'-'+type;\nflow.set(\"deploymentname\",deploymentname);\n// Getting the previous and next node plus setting up a varialble to find if the needed variables (appmodule, appconfig and gitprofileurl)\n// are included or not in the template that the user provided plus an helping object\nvar previousnode = flow.get(\"previousnode\");\nvar nextnode = flow.get(\"nextnode\");\nvar myeenvvar = 'variables';\nvar obj = {};\n// Get the broker url, set the previous, next, own node id and get the type of the app.\nappconfig.broker = 'mqtt://'+global.get(\"broker\");\nif (previousnode !== 0) {\n    appconfig.previousnode = previousnode;\n}\nappconfig.nextnode = nextnode;\nappconfig.mynodeid = flow.get(\"mynodeid\");\nappconfig.type = type;\n// Fill the template with the corresponing data\ntemplate.metadata.labels.app = type;\ntemplate.metadata.name = deploymentname;\ntemplate.spec.selector.matchLabels.app = type;\ntemplate.spec.template.metadata.labels.app = type;\ntemplate.spec.template.spec.containers[0].name = (type+'container');\n// Some loops to check for the three needed variables that are included in the deployment template\nfor (let i = 0; i < template.spec.template.spec.containers[0].env.length; i++) {\n    switch(template.spec.template.spec.containers[0].env[i].name) {\n    case 'appmodule':\n    template.spec.template.spec.containers[0].env[i].value = type;\n    myeenvvar=myeenvvar+'appmodule';\n    break;\n    case 'appconfig':\n    // We encode the data of the config that we pass to our app.\n    // Needed because the data contains characters that break the initiating bash script during the boot up. \n    template.spec.template.spec.containers[0].env[i].value = \"'\"+Buffer.from(JSON.stringify(appconfig)).toString('base64')+\"'\";\n    myeenvvar=myeenvvar+'appconfig';\n    break;\n    case 'gitprofileurl':\n    template.spec.template.spec.containers[0].env[i].value = global.get(\"gitprofileurl\");\n    myeenvvar=myeenvvar+'gitprofileurl';\n    break;\n    default:\n    }\n}\nif (myeenvvar.search(\"appmodule\") === -1){\n    obj[\"name\"] = \"appmodule\";\n    obj[\"value\"] = type;\n    template.spec.template.spec.containers[0].env.push(obj);\n}\nif (myeenvvar.search(\"appconfig\") === -1){\n    obj = {};\n    obj[\"name\"] = \"appconfig\";\n    // Same as before\n    obj[\"value\"] = \"'\"+Buffer.from(JSON.stringify(appconfig)).toString('base64')+\"'\";\n    template.spec.template.spec.containers[0].env.push(obj);\n}\nif (myeenvvar.search(\"gitprofileurl\") === -1){\n    obj = {};\n    obj[\"name\"] = \"gitprofileurl\";\n    obj[\"value\"] = global.get(\"gitprofileurl\");\n    template.spec.template.spec.containers[0].env.push(obj);\n}\n// Build the final message, load payload with the template and add the url that we send our request\nmsg.payload=JSON.stringify(template);\nmsg.method = 'POST';\nmsg.url = 'http://'+global.get(\"kubeproxy\")+'/apis/apps/v1/namespaces/default/deployments';\nreturn msg;","outputs":1,"noerr":0,"x":650,"y":60,"wires":[["5fedc483.73a98c"]]},{"id":"3cbdc32c.886c7c","type":"http request","z":"9cb03ea4.80c4d","name":"","method":"use","ret":"obj","paytoqs":false,"url":"","tls":"","persist":false,"proxy":"","authType":"","x":1190,"y":60,"wires":[["ade3b386.83d13","565a54fb.72190c"]]},{"id":"24de8143.2a84fe","type":"subflow:10db5822.97cf88","z":"11ac64d5.10699b","name":"","env":[{"name":"nameid","value":"test","type":"str"},{"name":"kubeproxy","value":"192.168.2.241:8080","type":"str"},{"name":"broker","value":"192.168.2.241:1883","type":"str"},{"name":"gitprofileurl","value":"https://github.com/aknts/","type":"str"}],"x":350,"y":100,"wires":[["87c6560e.3d9028"]]},{"id":"ade3b386.83d13","type":"function","z":"9cb03ea4.80c4d","name":"CheckAndChangeURL","func":"// First check if we did't get a failure message during deployment \n// and then change the url to request for its status before we proceed\nvar output1;\nvar output2;\nif ((msg.payload.status == \"Failure\") && (msg.payload.reason != \"AlreadyExists\")) {\n    node.status({fill:\"red\",shape:\"dot\",text:\"Node deployment failed\"});\n    throw(msg.payload.message);\n} else if ((msg.payload.status == \"Failure\") && (msg.payload.reason == \"AlreadyExists\")) {\n    node.status({fill:\"green\",shape:\"dot\",text:\"Node already exists\"});\n    output1 = null;\n    msg.payload=flow.get(\"nextnode\");\n    output2 = msg;\n} else {\n    msg.payload = '';\n    // If we are patching a deployment, we clean the msg and change the url to be able to get the status message.\n    if (msg.method == 'PATCH'){\n        msg.url = msg.url+'/status';\n    } else {\n        msg.url = msg.url+'/'+flow.get(\"deploymentname\")+'/status';\n    }\n    delete msg.method;\n    delete msg.md5;\n    output1 = msg;\n    output2 = null;\n}\nreturn [output1, output2];","outputs":2,"noerr":0,"x":1400,"y":60,"wires":[["f16f650a.9ab0b8"],["f18af736.3a7038"]]},{"id":"73eaca54.272cd4","type":"http request","z":"9cb03ea4.80c4d","name":"","method":"GET","ret":"obj","paytoqs":false,"url":"","tls":"","persist":false,"proxy":"","authType":"","x":1790,"y":60,"wires":[["9a0739ec.1d5eb8","7aa5e0ff.78711"]]},{"id":"7aa5e0ff.78711","type":"function","z":"9cb03ea4.80c4d","name":"CheckStatusMessages","func":"// After requesting for the status of deployment, we get a json object we need to filter out our information\n// If succesfull deployment then pass an ok message to avoid looping through this and deploy the rest of the nodes\nvar output1;\nvar output2;\nvar condition=msg.payload.status.conditions[0];\n\nif ((condition.type == \"Available\") && (condition.status == \"True\")) {\n    msg.payload=flow.get(\"nextnode\");\n    output1=msg;\n    output2=null;\n    node.status({fill:\"green\",shape:\"dot\",text:\"Node deployed\"});\n    node.done('Deployment of '+flow.get(\"deploymentname\")+' is finished.');\n} \n\nif ((condition.type == \"Progressing\") && (condition.status == \"True\")) {\n    msg.payload=flow.get(\"nextnode\");\n    output1=msg;\n    output2=null;\n    node.status({fill:\"green\",shape:\"dot\",text:\"Node redeployed\"});\n    node.done(condition.message);\n} \n\nif (msg.payload.status == \"Failure\") {\n    node.status({fill:\"yellow\",shape:\"dot\",text:\"Status fail\"});\n    node.warn(msg.payload.message);\n    msg.retry = msg.retry+1;\n    output1=null;\n    output2=msg;\n} \n\nif (msg.retry == 3){\n    node.warn('Status failed, continuing. Please check your deployment through kubectl.');\n    msg.payload=flow.get(\"nextnode\");\n    output1=msg;\n    output2=null;\n    node.status({fill:\"green\",shape:\"dot\",text:\"Node redeployed\"});\n    node.done(condition.message);\n}\n\nif (condition == 'undefined') {\n    output1=null;\n    output2=msg;\n    node.status({fill:\"yellow\",shape:\"dot\",text:\"Node deployed with some warnings\"});\n    node.done('Deployment of '+flow.get(\"deploymentname\")+' is finished. Maybe some warnings have poped up in the debug window. Please check.')\n}\n\n\nreturn [output1,output2];","outputs":2,"noerr":0,"x":2020,"y":120,"wires":[[],["f16f650a.9ab0b8"]]},{"id":"9a0739ec.1d5eb8","type":"debug","z":"9cb03ea4.80c4d","name":"","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","x":1990,"y":180,"wires":[]},{"id":"68b62ab8.e62fd4","type":"http request","z":"10db5822.97cf88","name":"","method":"GET","ret":"obj","paytoqs":false,"url":"http://localhost:1880/flows","tls":"","persist":false,"proxy":"","authType":"","x":450,"y":60,"wires":[["1a4c35c9.570a8a"]]},{"id":"9ddecb56.4f7548","type":"status","z":"10db5822.97cf88","name":"","scope":["1a4c35c9.570a8a"],"x":80,"y":160,"wires":[[]]},{"id":"1a4c35c9.570a8a","type":"function","z":"10db5822.97cf88","name":"GetNodesOrder","func":"// From the previous step we get a payload with all the live flows that node-red has \n// plus set up some variables and arrays to help us find the id of each subflow node \nvar data=msg.payload;\nmsg.payload='';\nvar nameid=global.get(\"nameid\");\nvar envar;\nvar flowid;\nvar flownodes = [];\nvar deletedeploys = [];\nvar numberofnodes;\nvar flownodesorder = [];\nif (global.get(\"flownodesorder\")){\n    var flownodesordertemp = global.get(\"flownodesorder\");\n}\nif (global.get(\"flownodesappname\")){\n    var flownodesappname = global.get(\"flownodesappname\");\n} else {\n    flownodesappname = [];\n}\nvar modifiednodes;\nvar i=0;\nvar ii=0;\n\n// A function to compare two arrays\nfunction comparearrays (a1, a2) {\n    var a = [], diff = [];\n    for (var i = 0; i < a1.length; i++) {\n        a[a1[i]] = true;\n    }\n    for (i = 0; i < a2.length; i++) {\n        if (a[a2[i]]) {\n            delete a[a2[i]];\n        } else {\n            a[a2[i]] = true;\n        }\n    }\n    for (var k in a) {\n        diff.push(k);\n    }\n    return diff;\n}\n\n// With the enviromental variable nameid that only this subflow has we pinpoint which is the current flow id and pass it to a global variable\ndata.forEach(element => {\n    if (element.type.includes(\"subflow:\")) {\n        if (element.env) { \n            envar = element.env;\n            envar.forEach(envarelement => {\n                if (envarelement.value == nameid) {\n                    flowid = element.z;\n                    global.set(\"flowid\",flowid);\n                }\n            });\n       }\n    }\n});\n// Nodes that in their object have the z field with the flow's id means that are the main flow's nodes and we push in an array their id and their wires variable\n// The wires describe to whom their output is connected to\ndata.forEach(element => {\n    if ((element.z == flowid) && (element.type.includes(\"subflow:\"))) {\n        if (element.wires[0][0]) {\n            flownodes.push([element.id.replace(\".\", \"\"),element.wires[0][0].replace(\".\", \"\")]);\n        } else {\n            flownodes.push([element.id.replace(\".\", \"\"),null]);\n        }\n    }\n});\nnumberofnodes = flownodes.length;\n// The node that doesn't have wires is the last one and from that one we trace back the order of the nodes\nflownodes.forEach(element => {\n   if (element[1] == null) {\n       flownodesorder.push(element[0].replace(\".\", \"\"));\n   }\n});\n\n// We trace back the order of the nodes by checking the node's id to whom nodes is marked as a wire, when we found the node, we push it to the array and start again until the end\nwhile (flownodesorder.length < numberofnodes) {\n    if (flownodes[i][1] == flownodesorder[ii]) {\n        flownodesorder.push(flownodes[i][0]);\n        //flownodesorder[ii] = flownodesorder[ii].replace(\".\", \"\");\n        ii++;\n        i=0;\n    } else {\n        i++;\n    }\n}\n\n// After we fill our array, we reverse it to mark the proper order\n// Finally we compare and find if a node has been deleted from the flow by comparing the nodes ids\n// After we get the id of the nodes we build a delete request that will delete the deployment\nflownodesorder=flownodesorder.reverse();\n\nif (Array.isArray(flownodesordertemp) && flownodesordertemp.length) {\n    modifiednodes=comparearrays(flownodesorder,flownodesordertemp);\n    for (i = 0; i < modifiednodes.length; i++) {\n        if (!flownodesorder.includes(modifiednodes[i])) {\n            for (ii = 0; ii < flownodesappname.length; ii++) {\n                if (flownodesappname[ii].nodeid == modifiednodes[i]){\n                    var msg2={};\n                    msg2.payload = 'gracePeriodSeconds: 0\\r\\norphanDependents: false';\n                    msg2.headers = {};\n                    msg2.headers[\"Content-Type\"] = 'application/yaml';\n                    msg2.url = 'http://'+global.get(\"kubeproxy\")+'/apis/apps/v1/namespaces/default/deployments/'+nameid+'-'+modifiednodes[i]+'-'+flownodesappname[ii].type;\n                    node.warn(msg2);\n                    node.warn(\"The deployment with name \"+nameid+'-'+modifiednodes[i]+'-'+flownodesappname[ii].type+\" must be deleted.\");\n                    flownodesappname.splice(ii,1);\n                    for (iii = 0; iii < modifiednodes.length; iii++) {\n                        if (flownodesorder == modifiednodes[i]){\n                            flownodesorder.splice(iii, 1)\n                        }\n                    }\n                    deletedeploys.push(msg2);\n                } else {\n                    msg2 = null;\n                }\n            }\n        }\n    }\n} else {\n    msg2 = null;\n}\n// After building our output variable wee feed them to the outputs of the subflow.\nglobal.set(\"flownodesorder\",flownodesorder);\nglobal.set(\"flownodesappname\",flownodesappname);\nmsg.payload = flownodesorder[1];\nnode.status({fill:\"green\",shape:\"dot\",text:\"Settings passed check\"});\nreturn [msg,deletedeploys];","outputs":2,"noerr":0,"x":640,"y":60,"wires":[[],["80e62f76.a72d8"]]},{"id":"e1109825.402358","type":"function","z":"9cb03ea4.80c4d","name":"FindNeighbors","func":"// Get node's id from incoming message, \n// set it as a variable for this function node and also as a flow variable to be accesible downstream\n// and finally get the order of nodes in the master flow\nvar mynodeid = msg.payload;\nflow.set(\"mynodeid\",mynodeid)\nvar flownodesorder = global.get(\"flownodesorder\");\n// Loop through the master's flow order, locate this subflow id and get the index of the position\nvar i=0;\nwhile (i < flownodesorder.length) {\n    if (flownodesorder[i] == mynodeid) {\n        var ii=i;\n    }\n    i++;\n}\n// Use the index that we found in previous state to find the previous and next subflow node id\n// Set two variables that are passed to the final deployment, this way we arrange to which node our app can send/receive messages through the mqtt broker\nif (ii > 1) {\n    flow.set(\"previousnode\",flownodesorder[ii-1]);\n} else {\n    flow.set(\"previousnode\",0);\n}\nif (ii < flownodesorder.length-1) {\n    flow.set(\"nextnode\",flownodesorder[ii+1])\n} else {\n    flow.set(\"nextnode\",0);\n}\nreturn msg;","outputs":1,"noerr":0,"x":460,"y":60,"wires":[["65747409.f4e33c"]]},{"id":"5900feb6.71b4b","type":"status","z":"9cb03ea4.80c4d","name":"","scope":null,"x":80,"y":160,"wires":[[]]},{"id":"b8c37fb5.c5862","type":"inject","z":"11ac64d5.10699b","name":"Start","topic":"","payload":"","payloadType":"date","repeat":"","crontab":"","once":false,"onceDelay":0.1,"x":90,"y":100,"wires":[["24de8143.2a84fe"]]},{"id":"8b475ac3.83c4f8","type":"function","z":"10db5822.97cf88","name":"CheckEnviromentalVariables","func":"// Check if form fields are not empty and set corresponing global values\nif (env.get(\"nameid\") == \"\") {\n    node.status({fill:\"red\",shape:\"dot\",text:\"Form not filled correclty.\"});\n    throw(\"Pipeline name is empty.\");\n} else {\n    global.set(\"nameid\", env.get(\"nameid\"))\n}\nif (env.get(\"kubeproxy\") == \"\") {\n    node.status({fill:\"red\",shape:\"dot\",text:\"Form not filled correclty.\"});\n    throw(\"Kubectl proxy is empty.\");\n} else {\n    global.set(\"kubeproxy\", env.get(\"kubeproxy\"))\n}\nif (env.get(\"broker\") == \"\") {\n    node.status({fill:\"red\",shape:\"dot\",text:\"Form not filled correclty.\"});\n    throw(\"MQTT Broker is empty.\");\n} else {\n    global.set(\"broker\", env.get(\"broker\"))\n}\nif (env.get(\"gitprofileurl\") == \"\") {\n    node.status({fill:\"red\",shape:\"dot\",text:\"Form not filled correclty.\"});\n    throw(\"Base git profile is empty.\");\n} else {\n    global.set(\"gitprofileurl\", env.get(\"gitprofileurl\"))\n}\nnode.status({fill:\"green\",shape:\"dot\",text:\"Settings passed check\"});\nreturn msg;","outputs":1,"noerr":0,"x":220,"y":60,"wires":[["68b62ab8.e62fd4"]]},{"id":"565a54fb.72190c","type":"debug","z":"9cb03ea4.80c4d","name":"","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"true","targetType":"full","x":1390,"y":180,"wires":[]},{"id":"f16f650a.9ab0b8","type":"delay","z":"9cb03ea4.80c4d","name":"","pauseType":"delay","timeout":"5","timeoutUnits":"seconds","rate":"1","nbRateUnits":"1","rateUnits":"second","randomFirst":"1","randomLast":"5","randomUnits":"seconds","drop":false,"x":1620,"y":100,"wires":[["73eaca54.272cd4","f18af736.3a7038"]]},{"id":"e1a1287f.cfd378","type":"function","z":"9cb03ea4.80c4d","name":"CheckEnviromentalVariables","func":"if (env.get(\"type\") == \"\") {\n    node.status({fill:\"red\",shape:\"dot\",text:\"Form not filled correclty.\"});\n    throw(\"App module is empty.\");\n} else {\n    flow.set(\"type\", env.get(\"type\"))\n}\nif (env.get(\"template\") == \"\") {\n    node.status({fill:\"red\",shape:\"dot\",text:\"Form not filled correclty.\"});\n    throw(\"Deployment template is empty.\");\n} else {\n    flow.set(\"template\", env.get(\"template\"))\n}\nreturn msg;","outputs":1,"noerr":0,"x":220,"y":60,"wires":[["e1109825.402358"]]},{"id":"80e62f76.a72d8","type":"http request","z":"10db5822.97cf88","name":"","method":"DELETE","ret":"txt","paytoqs":false,"url":"","tls":"","persist":false,"proxy":"","authType":"","x":810,"y":200,"wires":[["a552106d.663ae"]]},{"id":"a552106d.663ae","type":"debug","z":"10db5822.97cf88","name":"","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","x":1000,"y":200,"wires":[]},{"id":"5fedc483.73a98c","type":"md5","z":"9cb03ea4.80c4d","name":"","fieldToHash":"payload","fieldTypeToHash":"msg","hashField":"md5","hashFieldType":"msg","x":810,"y":60,"wires":[["75fb2395.803bcc"]]},{"id":"75fb2395.803bcc","type":"function","z":"9cb03ea4.80c4d","name":"CompareConfigs","func":"// In the previous step we have produced an md5 hash feeding the template.\n// We keep the hash in a gloabal array and this way we can know if the template is altered.\n// If altered we change the url and feed it to the api to change the deployment that already exists.\n// If a previous hash doesn't exist we add a new object to the array and change the url to build the deployment.\n\n// Some vars for all the previous steps\nvar template=flow.get(\"template\");\nvar type=flow.get(\"type\");\nvar mynodeid=flow.get(\"mynodeid\");\nvar deploymentname = global.get(\"nameid\")+'-'+mynodeid+'-'+type;\nvar confighash = msg.md5;\nvar nodeexists = 0;\nvar appconfig={};\nvar appnameobj = {};\nvar flownodesappname = global.get(\"flownodesappname\");\n// A for to patch the deployment in case that the tempate is changed . If the main app is changed the deployment stops. \nif (Array.isArray(flownodesappname) || flownodesappname.length) {\n    for (let i = 0; i < flownodesappname.length; i++) {\n        if (flownodesappname[i].nodeid == mynodeid) {\n            nodeexists = 1;\n            node.warn(flownodesappname[i].type+'-'+type);\n            if (flownodesappname[i].type != type) {\n                throw(\"The main app has changed, redeployment has stopped. Please delete deployment and add a new node with the new app.\")\n            }\n            if (flownodesappname[i].confighash != confighash) {\n                flownodesappname[i].confighash = confighash;\n                msg.url = 'http://'+global.get(\"kubeproxy\")+'/apis/apps/v1/namespaces/default/deployments/'+deploymentname;\n                msg.method = 'PATCH';\n                msg.headers = {};\n                msg.headers[\"Content-Type\"] = 'application/strategic-merge-patch+json';\n            }\n        }\n    }\n}\n// If the deployment is a new one, we add a new object to our list.\nif (nodeexists == 0){\n    appnameobj[\"nodeid\"] = mynodeid;\n    appnameobj[\"type\"] = type;\n    appnameobj[\"confighash\"] = confighash;\n    flownodesappname.push(appnameobj);\n    global.set(\"flownodesappname\",flownodesappname);\n    msg.url = 'http://'+global.get(\"kubeproxy\")+'/apis/apps/v1/namespaces/default/deployments';\n    msg.method = 'POST';\n}\n// Final parsing before the http request.\nnode.warn(global.get(\"flownodesappname\"));\nmsg.payload = JSON.parse(msg.payload);\nreturn msg;","outputs":1,"noerr":0,"x":990,"y":60,"wires":[["3cbdc32c.886c7c","140b6268.2c228e"]]},{"id":"140b6268.2c228e","type":"debug","z":"9cb03ea4.80c4d","name":"","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"true","targetType":"full","x":1180,"y":180,"wires":[]},{"id":"f18af736.3a7038","type":"debug","z":"9cb03ea4.80c4d","name":"","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"true","targetType":"full","x":1780,"y":200,"wires":[]},{"id":"87c6560e.3d9028","type":"subflow:9cb03ea4.80c4d","z":"11ac64d5.10699b","name":"","x":600,"y":100,"wires":[["ac82d429.fc5028"]]},{"id":"ac82d429.fc5028","type":"subflow:9cb03ea4.80c4d","z":"11ac64d5.10699b","name":"","env":[{"name":"template","value":"{\"apiVersion\":\"apps/v1\",\"kind\":\"Deployment\",\"metadata\":{\"labels\":{\"app\":\"mqtttestapp\"},\"name\":\"mqtttestapp\",\"namespace\":\"default\"},\"spec\":{\"replicas\":2,\"selector\":{\"matchLabels\":{\"app\":\"mqtttestapp\"}},\"strategy\":{\"rollingUpdate\":{\"maxSurge\":1,\"maxUnavailable\":0},\"type\":\"RollingUpdate\"},\"template\":{\"metadata\":{\"labels\":{\"app\":\"mqtttestapp\"}},\"spec\":{\"imagePullSecrets\":[{\"name\":\"regcred\"}],\"containers\":[{\"name\":\"mqtttestappcontainer\",\"image\":\"aknts/mqttstrand:latest\",\"env\":[{\"name\":\"appmodule\",\"value\":\"mqtttestapp\"},{\"name\":\"appconfig\",\"value\":\"mqtttestappconfig\"},{\"name\":\"gitprofileurl\",\"value\":\"\"}],\"imagePullPolicy\":\"IfNotPresent\",\"resources\":{\"requests\":{\"cpu\":\"500m\",\"memory\":\"64Mi\"}}}],\"restartPolicy\":\"Always\"}}}}","type":"json"}],"x":840,"y":100,"wires":[["7c3a24af.812bdc"]]},{"id":"7c3a24af.812bdc","type":"subflow:9cb03ea4.80c4d","z":"11ac64d5.10699b","name":"","x":1100,"y":100,"wires":[[]]}]